# CONTENIDO DEL TEMA 1
**Linux y Procesos**

1. **PDF 1** con una introducción a los Sistemas Operativos y en específico al GNU Linux [VER](Tema-01-1.pdf)
2. **PDF 2** con la teoría de Procesos [VER](Tema-01-2.pdf)

Dentro del PDF 2 se tratan los siguientes recursos, en este orden sugerido:

- **programa01_print-pid.c** Este programa muestra el PID y el PPID del proceso actual [VER](programa01_print-pid.c)
- **programa02_ids.c** Este programa muestra el UID (User Identifier) tanto el real como el efectivo, del proceso actual [VER](programa02_ids.c)
- **PDF** de la tarea 1, que muestra cómo modificar el bit "setuid" para que los UIDs (User Identifiers) el real y el efectivo, del proceso actual sean diferentes [VER](Tarea-01.pdf)
- **Archivo PNG** que muestra gráficamente la función system( "comando" ) [VER](1_funcion_system.png)
- **programa03_system_v1.c** Este programa muestra la funcion system( "comando" ) ejecutando un comando correctamente, tal y como está en el PDF página 6: "ls -l /" [VER](programa03_system_v1.c)
- **programa03_system_v2.c** Este programa muestra la funcion system( "comando" ) ejecutando un comando correctamente y otro comando incorrectamente: "ls -l no_existe" además este programa involucra las macros WIFEXITED( valor_retorno ) y WEXITSTATUS( valor_retorno ) para observar el código de sistema a partir del código de retorno de la función system( "comando" ) [VER](programa03_system_v2.c)
- **programa04_error.c** Este programa muestra los códigos de sistema, utilizando sys_nerr y sys_errlist[i] los cuales ya están obsoletos o desaprobados, por lo que este programa puede enviar aviso (warning) o error al compilar [VER](programa04_error.c)
- **programa05_error.c** Este programa muestra los códigos de sistema, utilizando strerror( i ) por lo que es la alternativa al programa04_error1.c [VER](programa05_error.c)
- **programa06_error3.c** Este programa muestra los códigos de sistema, utilizando la variable errno y la función strerror( errno ). La intención de este programa es demostrar que la variable errno se establece por sistema. Se sugiere que previamente exista un archivo llamado antes.txt porque se va a renombrar a despues.txt para que la primera ejecución sea exitosa. En la segunda ejecución generará error [VER](programa06_error3.c)
- **programa07_error4.c** Este programa es una variante del anterior programa06_error3.c muestra la función perror( "string" ) la cual personaliza el mensaje de error anteponiendo un mensaje de usuario seguido de ":" [VER](programa07_error4.c)
- **Archivo PNG** que muestra gráficamente la función fork() [VER](2_funcion_fork_1.png)
- **Archivo PNG** que muestra gráficamente la función fork() aplicada al programa08. Observa que la variable id_hijo la tienen tanto el proceso padre como el hijo, pero con valores diferentes, porque contiene lo que les devuelve la función fork(). La función fork() le devuelve al padre el pid del hijo (valor != 0) y al proceso hijo le devuelve el valor 0. [VER](2_funcion_fork_2.png)
- **programa08_fork1.c** Este programa muestra la funcion fork(), se observa que se crea un proceso hijo idéntico al padre, por lo que a partir de la llamada a fork() en adelante, se ejecutarán 2 procesos en paralelo, de manera asíncrona. Los printf() se imprimirán por duplicado. [VER](programa08_fork1.c)
- **programa09_fork2.c** Este programa muestra la funcion fork(), se observa que se crea un proceso hijo idéntico al padre, por lo que a partir de la llamada a fork() en adelante, se ejecutarán 2 procesos en paralelo, de manera asíncrona. En este caso, se evalúa el valor de retorno de fork(). Si es un valor no-cero, entonces es el proceso padre, ya que corresponde al PID del hijo. Al proceso hijo, fork() le devuelve cero [VER](programa09_fork2.c)
- **programa10_child.c** Este programa muestra la funcion fork(). En este programa primero se evalúa si fork() falla y devuelve -1. En ese caso, se llama a perror("fork") y a EXIT_FAILURE. En caso de éxito, después se evalúa si es el proceso padre o el hijo. Si es un valor no-cero, entonces es el proceso padre, ya que corresponde al PID del hijo. Al proceso hijo, fork() le devuelve cero [VER](programa10_child.c)
- **Archivo PNG** que muestra gráficamente la familia de funciones exec() [VER](3_funcion_exec.png)
- **Qué es la imagen de un proceso?** [VER](https://www.hpca.ual.es/~vruiz/docencia/cursos/linux/html/node43.html)
- **Función exec (llamada al sistema)** [VER](https://es.wikibrief.org/wiki/Exec_%28system_call%29)
- **programa11_execl.c** Este programa muestra la funcion execl() ejecutando un comando correctamente: "/bin/ls -l /" Revisa los comentarios dentro del código [VER](programa11_execl.c)
- **programa12_execv.c** Este programa muestra la funcion execv() ejecutando un comando correctamente: "/bin/ls -l /" Revisa los comentarios dentro del código [VER](programa12_execv.c)
- **programa13_getenv_user1.c** Este programa muestra cómo obtener el valor de la variable de entorno USER, con la función getenv( "VARIABLE" ) [VER](programa13_getenv_user1.c)
- **programa14_getenv_user2.c** Este programa muestra cómo obtener el valor de la variable de entorno USER y de una variable de entorno inexistente que se llama MI_VARIABLE, utilizando la función getenv( "VARIABLE" ) para ambos casos [VER](programa14_getenv_user2.c)
- **programa15_execle1.c** Este programa muestra la funcion execle() ejecutando un comando correctamente: "/bin/ls -l /" Revisa los comentarios dentro del código [VER](programa15_execle1.c)
- **programa16_execle2.c** Este programa muestra la funcion execle(). A diferencia del programa anterior (programa15) en el que se ejecuta un comando que no requiere las variables de entorno personalizadas, este programa llama al programa ./programa13_getenv_user1 y para esta ejecución se personaliza la variable de entorno USER reemplazando el valor que tiene en sistema por el valor "joe". Revisa los comentarios dentro del código [VER](programa16_execle2.c)
- **programa17_execle3.c** Este programa muestra la funcion execle(), semejante al programa anterior (programa16). En este programa, además de la variable de entorno USER, se utiliza una variable de entorno inexistente (MI_VARIABLE) la cual se utilizó en el código ./programa14_getenv_user2 imprimiendo (null). En este caso, se declara el valor MI_VARIABLE="acs" y se llama al programa14. Revisa los comentarios dentro del código [VER](programa17_execle3.c)
- **programa18_execve1.c** Este programa muestra la funcion execve(), semejante al programa anterior (programa17), también llama al programa ./programa14_getenv_user2 imprimiendo las 2 variables de entorno: USER=joe y MI_VARIABLE=acs. La diferencia es que el programa anterior pasa los argumentos como lista y este programa pasa los argumentos como vector/arreglo. Revisa los comentarios dentro del código [VER](programa18_execve1.c)
- **programa19_execlp.c** Este programa muestra la funcion execlp() ejecutando un comando correctamente: "ls -l /". Esta función no requiere la ruta absoluta del comando ya que toma el valor de la variable de entorno PATH. Revisa los comentarios dentro del código [VER](programa19_execlp.c)
- **programa20_execvp.c** Este programa muestra la funcion execvp() ejecutando un comando correctamente: "ls -l /". Esta función no requiere la ruta absoluta del comando ya que toma el valor de la variable de entorno PATH. Este programa es parecido al anterior (programa19) pero la diferencia está en que programa19 pasa los argumentos como lista y programa20 pasa los argumentos como vector. Revisa los comentarios dentro del código [VER](programa20_execvp.c)
- **programa21_myecho.c** Este programa imprime en pantalla los argumentos que se le pasen, semejante al comando echo. Este programa puede ejecutarse desde línea de comandos, pero también se ejecutará desde el siguiente programa (programa22) [VER](programa21_myecho.c)
- **programa22_execve.c** Este programa llama al programa anterior por medio de la función execve y le pasa los argumentos "hola" "mundo" "buen" "dia" que están declarados en el código. La sintaxis de ejecución es: ./programa22_execve ./programa21_myecho [VER](programa22_execve.c)
- **programa23_fork-exec.c** Este programa usa fork-exec. Usa fork() para crear un nuevo hijo y ese hijo nuevo llama a execvp para llamar a un nuevo programa. Se demuestra que el proceso que llama a execvp es reemplazado por el proceso del nuevo programa. Es importante notar que no crea un nuevo proceso, lo comprobamos al pedir el PID tanto del programa que llama a execvp como del programa que es llamado por execvp. [VER](programa23_fork-exec.c)
- **programa24_fork-exec.c** Este programa usa fork-exec. Con base en el programa anterior, ahora el programa llamado desde execvp será el comando ls -l / Observa la salida y que el proceso padre no espera a que el proceso hijo termine. Este programa será la siguiente tarea (Tarea #2). Posteriormente vamos a ver la función wait() para solucionar la situación y que el proceso padre espere a que su hijo termine. [VER](programa24_fork-exec.c)
- **Archivo PNG** que muestra gráficamente el programa anterior programa24_fork-exec [VER](programa24_fork-exec.png)