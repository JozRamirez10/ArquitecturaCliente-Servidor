# CONTENIDO DEL TEMA 2
**"Estados de los Procesos"**

1. PDF con las notas de este tema [VER](01_Estados_de_procesos.pdf)

Dentro del PDF se tratan los siguientes recursos, en este orden sugerido:

- programa01_wait1.c Este programa consiste en crear un proceso hijo con fork() y posteriormente el proceso padre llama a la función wait( &estatus ) para entrar al estado de espera. Para simular procesamiento en el hijo, lo dormimos 10 segundos y posteriormente termina. Es hasta este punto que el padre sale de su estado de espera. La función wait( &estatus ) devuelve el PID del hijo que saca al padre de su estado de espera y además la función wait escribe en la variable estatus el código de salida del hijo, para ello se utilizan las macros WIFEXITED y WEXITSTATUS. [VER](programa01_wait1.c)
- programa02_wait2.c Este programa es similar al programa anterior, con la diferencia que en este programa el proceso padre crea 2 hijos [VER](programa02_wait2.c)
- programa03_fork-exec_v2.c Este programa está basado en el programa 24 del tema anterior (VER) en donde el padre no se espera a que el hijo termine. Aquí se aplica la función wait para que el padre espere a que el hijo termine y el prompt se muestra después del comando ls -l / [VER](programa03_fork-exec_v2.c)
- Tarea # 2 consiste en codificar el programa fork-exec tanto la versión 1, que es el que no tiene wait (programa 24 del Tema 01) como la versión 2 que sí tiene wait. Deben comentar lo más posible (sentencia por sentencia o en un texto abierto) y agregar capturas de pantalla de la ejecución de ambos programas.
- Archivo PNG que muestra gráficamente los 3 casos de señales [VER](senales.png)
- programa04_signal_caso1.c Este programa muestra el caso 1 del tema de señales, que consiste en ignorar la señal, para ello la función signal debe ser signal(SIGINT, SIG_IGN). Revisa los comentarios dentro del código [VER](programa04_signal_caso1.c)
- programa05_signal_caso2_v1.c Este programa muestra el caso 2 variante 1, el cual maneja la señal con un tratamiento propio del programador y después el proceso continúa ejecutándose. Revisa los comentarios dentro del código [VER](programa05_signal_caso2_v1.c)
- programa05_signal_caso2_v2.c Este programa muestra el caso 2 variante 2, el cual maneja la señal con un tratamiento propio del programador, pero a diferencia de la variante 1, aquí sí termina el proceso. Revisa los comentarios dentro del código [VER](programa05_signal_caso2_v2.c)
- programa06_signal_caso3.c Este programa muestra el caso 3 del tema de señales, que consiste en que la señal no se puede ni ignorar ni manejar, tal es el caso de la señal SIGKILL. Revisa los comentarios dentro del código [VER](programa06_signal_caso3.c)
- programa07_background.c Este programa está en un bloque while de 20 ciclos y en cada ciclo, el proceso duerme por 10 segundos. La intención es que durante este tiempo prueben cómo colocar un proceso en background (o segundo plano) presionando primero la combinación del par de teclas Control Z, para detener el proceso y tener nuevamente el prompt libre para escribir el comando bg. También intencionalmente, este proceso arroja mucho texto de salida para que vean lo que sucede cuando se pasa a background: Aunque hay salida de texto en consola, presionen enter para que el prompt siga libre esperando otro comando. Otra alternativa para colocar el proceso en background desde el inicio de su ejecución es colocar al final del ejecutable el simbolo &:
./ejecutable &
Revisa los comentarios dentro del código [VER](programa07_background.c)
- programa08_zombie.c Este programa muestra que si el hijo termina, envía una señal al padre (SIGCHLD o SIGCLD), pero está dormido por lo que la encola (la señal SIGCHLD se coloca en la cola de señales del proceso padre y cuando éste despierta, recibe la señal SIGCHLD de la cola de señales). Durante este lapso de tiempo (60 segundos) el hijo es un proceso zombi. Puedes comprobarlo en otra terminal con el comando ps -e -o pid,ppid,user,stat,cmd encontrarás el status Z+ y la palabra <defunct>. Revisa los comentarios dentro del código [VER](programa08_zombie.c)
- programa09_nozombie_v1.c Este programa muestra una solución para evitar que el hijo se haga proceso zombi. Consiste en ignorar la señal SIGCHLD o SIGCLD, por lo que el padre si completa su sueño de 60 segundos. Revisa los comentarios dentro del código [VER](programa09_nozombie_v1.c)
- programa09_nozombie_v2.c Este programa muestra una solución alterna al programa anterior para evitar que el hijo se haga proceso zombi. Consiste en implementar una funcion manejadora de señales, que maneja la señal SIGCHLD y hace que el proceso padre no complete su sueño de 60 segundos. Revisa los comentarios dentro del código [VER](programa09_nozombie_v2.c)
- programa10_SIGKILL.c Este programa indica qué señales pueden ser manejadas. El objetivo de este ejercicio es que desde otra terminal lances el comando kill -SIGXXX PID, donde SIGXXX es cada una de las señales como pueden ser SIGINT, SIGABRT, SIGTSTP, etc y el PID es el pid del proceso actual, es por esta razón que al ejecutarse, imprime el PID. Revisa los comentarios dentro del código [VER](programa10_SIGKILL.c)
- programa11_kill1.c Este programa muestra que el proceso inicial crea un hijo con fork() y después de crearlo, se duerme 10 segundos. Mientras tanto, el hijo entra en un ciclo infinito en el que imprime sus datos como pid y ppid y se duerme 1 segundo. Todo esto sucede en paralelo, por lo que pasados los 10 segundos, el padre despierta de su sueño y llama a la función kill(pid, SIGKILL) donde pid es el del hijo por lo que lo termina de manera fulminante. Revisa los comentarios dentro del código [VER](programa11_kill1.c)
- programa12_kill2.c Este programa es similar al anterior con la diferencia de que aquí se crean 2 hijos. Debido a que la variable pid del padre primero almacena el pid del hijo 1 y después la misma variable almacena el pid del hijo 2, cuando el padre llama a la función kill(pid, SIGKILL) termina al hijo 2 y posteriormente el padre termina con una llamada a exit(0). Observa qué sucede con el hijo 1. Revisa los comentarios dentro del código [VER](programa12_kill2.c)
- programa13_abort.c Este programa llama a la función abort() que manda la señal SIGABRT a él mismo y las sentencias posteriores ya no se ejecuta. Revisa los comentarios dentro del código [VER](programa13_abort.c)